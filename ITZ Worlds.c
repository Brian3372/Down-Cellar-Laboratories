#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    pwrExpand,      sensorAnalog)
#pragma config(Sensor, in3,    fBarPot,        sensorPotentiometer)
#pragma config(Sensor, in4,    mogoPot,        sensorPotentiometer)
#pragma config(Sensor, in5,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEnc,        sensorQuadEncoder)
#pragma config(Motor,  port2,           LD1,           tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           fBar,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           LD2,           tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           RD1,           tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           liftTop,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           liftBottomRight, tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           liftBottomLeft, tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           RD2,           tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          claw,          tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#include "./VRCNERD-nerd_robotc-cfdb3c0a39c3/libGyro/NERD_Gyro.c"//Jason's gyro library.
#include "./VRCNERD-nerd_robotc-cfdb3c0a39c3/libPID/NERD_PID.c" //Jason's PID library courtesy of Jason McKinney.
#include "./Truespeed.h" //Truespeed library courtesy of Jason McKinney.
#include "./SlewRate.c" //SlewRate library courtesy of Brian Boxell

#define driveEnc -SensorValue[leftEnc]

Gyro gyro;

PID drivePID;
PID gyroPID;
PID gyroDrivePID;
PID liftPID;
PID liftHoldPID;
PID mogoPID;
PID mogoHoldPID;
PID fBarPID;

SlewRate slewRate;

float gyroAngle = 0;
int time = 0;
int left = 1;
int auton = 1;
int autonIndex = 0;
int cones = 0;
int clawState = 1;
int mogoMax = 127;

bool changed = false;
bool liftOverride = true;
bool clawPause = false;
bool customHeight = false;
bool slewCut = false;
bool skills = false;

enum mogoPos {
	in = 3700,
	inish = 3600,
	out = 500,
	lower = 700,
	twenty = 700,
	userControl = 0
};
enum mogoPos mogoState = in;

enum fBarPos {
	down = 700,
	up = 2400
};
enum fBarPos fBarState = up;
//lif positions: rest, 1    2    3    4    5     6     7     8     9     10    11    12    13
int liftPos[] = {1500, 1600, 1700, 1800, 1900, 2000, 2100, 2200, 2300, 2400, 2500, 2600, 2700, 2800};
int liftState = 5;
int fBarPower = 0;
int liftHeight = 0;
int engaged = false;

float convert = 0.0533;

task monitorGyro();
task LCDScreen();
task clawTask();
task autoStack();
task fBarTask();
task liftMogoControl();
task drivePIDTask();
void driveTarget(int target, int accuracy, int time);
void gyroTurn(int target, int accuracy, int time);
void driveL(int val);
void driveR(int val);
void lowerStack();
void intakeMogo();
void twoConeTwenty();
void threeConeTwenty();
void threeConeTen();
void threeConeFive();
void fiveCone();
void programmingSkills();
void driveTo(int target);
int min(int a, int b);


/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	bStopTasksBetweenModes = false;
	bDisplayCompetitionStatusOnLcd = false;
	pidInit (fBarPID,  0.2, 0, 0, 999999999, 999999999,9999999,999999999);
	pidInit (drivePID, 0.25, 0, 0.1, 0, 100.0,5,15);
	pidInit(gyroDrivePID, 10, 0, 0.6, 0, 40,999999,9999999);
	pidInit(gyroPID, 8,  0, 0.38, 0, 10,99999,999999);
	slewRateInit(slewRate, 160);
	bLCDBacklight = true;
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDCenteredString(0,"Down Cellar Labs");
	displayLCDCenteredString(1,"Gyro init...");
	gyro_init(gyro, in2, 0);
	startTask(monitorGyro);
	wait1Msec(100);
	startTask(LCDScreen);
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	if(autonIndex == 0)
		twoConeTwenty();
	else if(autonIndex == 1)
		threeConeTwenty();
	else if(autonIndex == 2)
		threeConeTen();
	else if(autonIndex == 3)
		threeConeFive();
	else if(autonIndex == 4)
		fiveCone();
	else {
		programmingSkills();
		skills = true;
	}
}
void twoConeTwenty() {
	liftOverride = false;
	startTask(liftMogoControl);
	startTask(fBarTask);
	motor[claw] = -40;
	liftState = 11;
	wait1Msec(700);
	mogoState = out;
	wait1Msec(800);
	//	wait1Msec(200);
	//	fBarState = down;
	driveTo(1580);
	mogoState = in;
	driveTarget(1700,100,2200);
	wait1Msec(400);
	//	driveTarget(99999999,50,9999999
	liftState = 0;
	gyroTurn(0,3,500);
	wait1Msec(400);
	motor[claw] = 127;
	liftState = 3;
	driveTarget(300,50,700);

	wait1Msec(300);
	//cone 2
	fBarState = down;
	wait1Msec(400);
	//driveTarget(75,25,100);
	motor[claw] = -127;
	liftState = 0;
	wait1Msec(800);
	motor[claw] = -40;
	liftState = 6;
	wait1Msec(500);
	fBarState = up;
	//return to zones
	driveTarget(-1620,50, 2300);
	liftState = 0;
	gyroTurn(left*-45,5,1000);
	motor[claw] = 127;
	liftState = 9;
	driveTarget(-920,150, 1100);
	gyroTurn(left*-135,5, 1200);
//	motor[LD1] = motor[LD2] = motor[RD1] = motor[RD2] = 127;
//	wait1Msec(700);
	driveTarget(1100,50, 1000);
	//wait1Msec(500);
	mogoState = out;
	wait1Msec(700);
	mogoMax = 80;
	//	mogoState = in;
	liftState = 6;
	driveTarget(-600,100, 3000);
}
void threeConeTwenty() {
		liftOverride = false;
	startTask(liftMogoControl);
	startTask(fBarTask);
	motor[claw] = -40;
	liftState = 8;
	wait1Msec(600);
	mogoState = out;
	wait1Msec(800);
	//	wait1Msec(200);
	//	fBarState = down;
	driveTo(1490);
	mogoState = in;
	driveTarget(1700,100,2200);
	wait1Msec(700);
	//	driveTarget(99999999,50,9999999
	liftState = 0;
	gyroTurn(0,3,500);
	wait1Msec(500);
	motor[claw] = 127;
	liftState = 3;
	driveTarget(300,50,700);

	//cone 2
	fBarState = down;
	wait1Msec(300);
	//driveTarget(75,25,100);
	motor[claw] = -127;
	liftState = 0;
	wait1Msec(500);
	motor[claw] = -40;
	liftState = 6;
	wait1Msec(400);
	fBarState = up;
	wait1Msec(300);
	liftState = 0;
	wait1Msec(200);
	motor[claw] = 127;
	liftState = 6;
	//cone 3
	driveTarget(375,50, 700);
	fBarState = down;
	wait1Msec(300);
	motor[claw] = -127;
	liftState = 0;
	wait1Msec(700);
	motor[claw] = -50;
	liftState = 7;
	wait1Msec(200);
	fBarState = up;
	//return to zones
	driveTarget(-1900,50, 2300);
	liftState = 0;
	gyroTurn(left*-45,5,1000);
	motor[claw] = 127;
	liftState = 7;
	driveTarget(-920,150, 1100);
	gyroTurn(left*-135,5, 1200);
	motor[LD1] = motor[LD2] = motor[RD1] = motor[RD2] = 127;
	driveTarget(1310,50, 1120);
	//wait1Msec(500);
	mogoState = out;
//	motor[LD1] = motor[LD2] = motor[RD1] = motor[RD2] = 127;
	wait1Msec(700);
	//motor[LD1] = motor[LD2] = motor[RD1] = motor[RD2] = 60;
	SensorValue[rightEnc] = SensorValue[leftEnc] = 0;

	wait1Msec(1200);
	mogoMax = 80;
	//	mogoState = in;
	liftState = 6;
	driveTarget(-400,100, 3000);
}
void threeConeFive() {
	liftOverride = false;
	startTask(liftMogoControl);
	startTask(fBarTask);
	motor[claw] = -40;
	liftState = 12;
	wait1Msec(700);
	mogoState = out;
	wait1Msec(800);
	//	wait1Msec(200);
	//	fBarState = down;
	driveTo(1490);
	mogoState = in;
	driveTarget(1700,100,2200);
	wait1Msec(800);
	//	driveTarget(99999999,50,9999999
	liftState = 0;
	gyroTurn(0,3,500);
	wait1Msec(400);
	motor[claw] = 127;
	liftState = 3;
	driveTarget(300,50,700);
	wait1Msec(300);

	//cone 2
	fBarState = down;
	wait1Msec(400);
	//driveTarget(75,25,100);
	motor[claw] = -127;
	liftState = 0;
	wait1Msec(500);
	motor[claw] = -40;
	liftState = 6;
	wait1Msec(400);
	fBarState = up;
	wait1Msec(300);
	liftState = 0;
	wait1Msec(300);
	motor[claw] = 127;
	liftState = 6;
	//cone 3
	driveTarget(370,50, 700);
	fBarState = down;
	wait1Msec(300);
	motor[claw] = -127;
	liftState = 0;
	wait1Msec(500);
	motor[claw] = -50;
	liftState = 7;
	wait1Msec(200);
	fBarState = up;

	//return to zones
	driveTarget(-1600,150, 2300);
	liftState = 0;
	gyroTurn(left*175,5,1000);
	motor[claw] = 127;
	liftState = 9;
	//driveTarget(-330,50, 700);
	//gyroTurn(left*-143,5, 1200);
	wait1Msec(300);
	mogoState = out;
	//driveTarget(300, 50, 700);
	wait1Msec(1200);
	mogoMax = 80;
	//	mogoState = in;
	liftState = 7;
	driveTarget(-600,100, 3000);
//	mogoState = in;

}
void threeConeTen() {
	liftOverride = false;
	startTask(liftMogoControl);
	startTask(fBarTask);
	motor[claw] = -40;
	liftState = 11;
	wait1Msec(800);
	mogoState = out;
	wait1Msec(800);
	//	wait1Msec(200);
	//	fBarState = down;
	driveTo(1490);
	mogoState = in;
	driveTarget(1700,100,2200);
	wait1Msec(800);
	//	driveTarget(99999999,50,9999999
	liftState = 0;
	gyroTurn(0,3,500);
	wait1Msec(400);
	motor[claw] = 127;
	liftState = 3;
	driveTarget(300,50,700);
	wait1Msec(300);

	//cone 2
	fBarState = down;
	wait1Msec(400);
	//driveTarget(75,25,100);
	motor[claw] = -127;
	liftState = 0;
	wait1Msec(800);
	motor[claw] = -40;
	liftState = 6;
	wait1Msec(500);
	fBarState = up;
	wait1Msec(300);
	liftState = 0;
	wait1Msec(300);
	motor[claw] = 127;
	liftState = 6;
	//cone 3
	driveTarget(370,50, 700);
	fBarState = down;
	wait1Msec(300);
	motor[claw] = -127;
	liftState = 0;
	wait1Msec(500);
	motor[claw] = -50;
	liftState = 7;
	wait1Msec(200);
	fBarState = up;

	//return to zones
	driveTarget(-1900,50, 2300);
	liftState = 0;
	gyroTurn(left*-45,5,1000);
	motor[claw] = 127;
	liftState = 9;
	driveTarget(-330,50, 700);
	gyroTurn(left*-143,5, 1200);
	mogoState = out;
	driveTarget(300, 50, 700);
	wait1Msec(500);
	mogoMax = 80;
	//	mogoState = in;
	liftState = 7;
	driveTarget(-300,100, 3000);
	gyroTurn(left*-30, 5, 800);
//	mogoState = in;

}
void fiveCone() { //autonomous
	liftOverride = false;
	startTask(liftMogoControl);
	startTask(fBarTask);
	motor[claw] = -40;
	liftState = 8;
	wait1Msec(400);
	mogoState = out;
	wait1Msec(800);
	//	wait1Msec(200);
	//	fBarState = down;
	driveTo(1580);
	mogoState = in;
	driveTarget(1700,100,2200);
	wait1Msec(800);
	//	driveTarget(99999999,50,9999999
	liftState = 0;
	gyroTurn(0,3,500);
	wait1Msec(400);
	motor[claw] = 127;
	liftState = 3;
	driveTarget(300,50,700);
	wait1Msec(300);

	//cone 2
	fBarState = down;
	wait1Msec(400);
	//driveTarget(75,25,100);
	motor[claw] = -127;
	liftState = 0;
	wait1Msec(800);
	motor[claw] = -40;
	liftState = 6;
	wait1Msec(500);
	fBarState = up;
	wait1Msec(300);
	liftState = 0;
	wait1Msec(300);
	motor[claw] = 127;
	liftState = 6;
	//cone 3
	driveTarget(370,50, 700);
	fBarState = down;
	wait1Msec(300);
	motor[claw] = -127;
	liftState = 0;
	wait1Msec(500);
	motor[claw] = -50;
	liftState = 7;
	wait1Msec(200);
	fBarState = up;

	//return to zones
	driveTarget(-1900, 50, 2300);
	liftState = 0;
	//cone 4
	gyroTurn(left*45,5,1000);
	motor[claw] = 127;
	liftState = 7;
	wait1Msec(300);
	fBarState = down;
	wait1Msec(200);
	motor[claw] = -127;
	liftState = 0;
	wait1Msec(600);
	liftState = 7;
	//cone 5
	gyroTurn(left*25,5,500);
	fBarState = up;
	liftState = 1;
	wait1Msec(300);
	motor[claw] = 127;
	liftState = 8;
	driveTarget(300,40, 500);
	fBarState = down;
	wait1Msec(300);
	motor[claw] = -127;
	liftState = 0;
	wait1Msec(600);
	liftState = 9;
	wait1Msec(600);
	fBarState = up;
	wait1Msec(300);
	liftState = 2;
	wait1Msec(300);
	motor[claw] = 127;
	liftState = 10;
}
void programmingSkills() {
	liftOverride = false;
	startTask(liftMogoControl);
	startTask(fBarTask);
	motor[claw] = -40;
	liftState = 6;
	wait1Msec(500);
	mogoState = out;
	//	wait1Msec(200);
	fBarState = down;
	wait1Msec(800);
	fBarState = up;
	wait1Msec(1000);
	driveTarget(900,50, 2000);
	intakeMogo();
	mogoState = in;
	liftState = 2;
	motor[claw] = 127;
	//SensorValue[rightEnc] = SensorValue[leftEnc] = 0;
	driveTarget(-740, 50, 2000);
	gyroTurn(95,2, 2000);
	liftState = 11;
	driveTarget(550, 50, 2000);
	motor[claw] = 0;
	gyroTurn(-165, 2, 2000);
	motor[LD1] = motor[LD2] = motor[RD1] = motor[RD2] = 127;
	wait1Msec(1400);
	motor[LD1] = motor[LD2] = motor[RD1] = motor[RD2] = 0;
	SensorValue[rightEnc] = SensorValue[leftEnc] = 0;
	mogoState = out;
	wait1Msec(800);
	driveTarget(-500,50,2000);
	mogoState = in;
	//mogo 2
	gyroTurn(90,2,2000);
	driveTarget(320,50,2000);
	mogoState = out;
	gyroTurn(0,2,2000);
	driveTarget(600, 50, 2000);
	intakeMogo();
	mogoState = in;
	driveTarget(-620, 50, 2000);
	gyroTurn(-90, 2, 400);
	gyroTurn(165, 2, 2000);
	driveTarget(210,50,2000);
	mogoState = out;
	//mogo 3
	wait1Msec(800);
	motor[LD1] = motor[LD2] = motor[RD1] = motor[RD2] = -127;
	wait1Msec(400);
	mogoState = in;
	driveTarget(-500, 50, 2000);

	gyroTurn(90, 2, 400);
	gyroTurn(-34,2, 2000);
	mogoState = out;
	wait1Msec(1000);
	driveTarget(1200, 50, 4000);
	intakeMogo();
	mogoState = in;
	driveTarget(1300, 50, 2000);
	mogoState = out;
	wait1Msec(1000);
	//mogo 4
	motor[LD1] = motor[LD2] = motor[RD1] = motor[RD2] = -127;
	wait1Msec(200);
	driveTarget(-400, 20, 1000);
	mogoState = in;
	gyroTurn(-135, 2, 2000);
	driveTarget(750, 50, 2000);
	gyroTurn(130, 2, 2000);
	mogoState = out;
	wait1Msec(1000);
	driveTarget(600, 50, 2000);
	intakeMogo();
	mogoState = in;
	driveTarget(-650, 50, 2000);
	gyroTurn(-48,2, 2000);
	driveTarget(600, 50, 1000);
	mogoState = out;
	wait1Msec(1000);
	motor[LD1] = motor[LD2] = motor[RD1] = motor[RD2] = -127;
	wait1Msec(500);
	motor[LD1] = motor[LD2] = motor[RD1] = motor[RD2] = 0;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	stopTask(autonomous);
	mogoMax = 127;
	liftOverride = true;
	startTask(clawTask);
	startTask(liftMogoControl);
	//startTask(autoStack);
	startTask(fBarTask);
	startTask(monitorGyro);
	startTask(drivePIDTask);
	wait1Msec(100);
	int rightPower;
	int leftPower;
	while (true)
	{
		if (!engaged) {
			rightPower = ((vexRT[Ch2] - vexRT[Ch1]) >= 0 ? 1 : -1)*TrueSpeed[min(fabs(vexRT[Ch2] - vexRT[Ch1]),127)];
			leftPower = ((vexRT[Ch2] + vexRT[Ch1]) >= 0 ? 1 : -1)*TrueSpeed[min(fabs(vexRT[Ch2] + vexRT[Ch1]),127)];
			//rightPower += ((vexRT[Ch2Xmtr2]) >= 0 ? 1 : -1)*TrueSpeed[min(fabs(vexRT[Ch2Xmtr2]),127)];
			//leftPower += ((vexRT[Ch3Xmtr2]) >= 0 ? 1 : -1)*TrueSpeed[min(fabs(vexRT[Ch3Xmtr2]),127)];
			motor[RD1] = motor[RD2] = rightPower; // control drive with truespeed
			motor[LD1] = motor[LD2] = leftPower;
		}
		wait1Msec(20);
		if (vexRT[Btn5D]) {
			fBarState = (fBarState == up)? down : up;
			wait1Msec(250);
		}
		if (vexRT[Btn7D]) {
			lowerStack();
		}
		//	if (vexRT[Btn8D]) {
		//		intakeMogo();
		//	}
	}
}
task drivePIDTask() {
	engaged = false;
	SensorValue[leftEnc] = SensorValue[rightEnc] = 0;
	while (true) {
		if (engaged) {
			int drivePower = pidCalculate(drivePID, 0, driveEnc);
			motor[RD1] = motor[RD2] = 	motor[LD1] = motor[LD2] = drivePower;
		}
		if (vexRT[Btn7L]) {
			SensorValue[leftEnc] = SensorValue[rightEnc] = 0;
			engaged = !engaged;
			wait10Msec(250);
		}
		wait1Msec(20);
	}
}
task fBarTask() {
	while(true) {
		int fBarTarget = 0;
		if (fBarState == down) {
			fBarTarget = down;
		}
		else {
			/*if (SensorValue[liftPot] > 300)
				fBarTarget = 0.0002*SensorValue[liftPot]*SensorValue[liftPot]-1.1021*SensorValue[liftPot]+395;
			else
				fBarTarget = 2350;*/

			fBarTarget = up;
		}
		motor[fBar] =  fBarPower = pidCalculate(fBarPID, fBarTarget, SensorValue[fBarPot]);
		wait1Msec(20);
	}
}
task clawTask() {
	bool off = false;
	while(true) {
		if (!off) {
			if (vexRT[Btn6D] || changed) {
				if (clawState == 1) {
					motor[claw] = -127;
					wait1Msec(600);
				}
				else {
					motor[claw] = 127;
					wait1Msec(600);
					motor[claw] = -127;
					wait1Msec(600);
					clawState = 1;
				}
				clawState = (clawState ==1)? 0:1;
				wait1Msec(300);
				changed = false;
			}
			if(clawState == 0 &&!clawPause) {
				motor[claw] = -50;
			}
			wait1Msec(20);
		}
		else {
			motor[claw] = 0;
		}
		if (vexRT[Btn7U]) {
			off = !off;
			wait1Msec(300);
		}
	}
}
task autoStack() {
	while (true) {
		if(vexRT[Btn7L]) {
			liftState = cones;
			while(abs(SensorValue[liftPot] - liftPos[liftState])<30) wait1Msec(20);
			fBarState = up;
			while(abs(SensorValue[fBarPot] - up)<30) wait1Msec(20);
			liftState = cones-1;
			wait1Msec(300);
			clawPause = true;
			motor[claw] = -127;
			wait1Msec(200);
			motor[claw] = -20;
			liftState = cones+1;
			wait1Msec(800);
			fBarState = down;
			while(abs(SensorValue[fBarPot] - down)<30) wait1Msec(20);
			liftState = 0;
			while(abs(SensorValue[liftPot] - liftPos[liftState])<30) wait1Msec(20);
			clawPause = false;
		}
		wait1Msec(20);
	}
}

//Controls the Lift/Mogo Transmission
task liftMogoControl() {
	int mogoCalculate = 0;
	int liftCalculate = 0;
	pidInit (liftPID,  0.1, 0, 0, 5.0, 150.0,9999999,999999999);
	pidInit (liftHoldPID,  0,0,0, 5.0, 150.0,9999999,999999999);
	pidInit (mogoPID,  0.2, 0, 0, 5.0, 150.0,9999999,999999999);
	pidInit (mogoHoldPID,  1, .1, .1, 5.0, 150.0,9999999,999999999);
	int mogoPIDval = 0;
	while (true) {
		if (!liftOverride) {
			mogoPIDval = -pidCalculate(mogoPID, mogoState, SensorValue[mogoPot]);
			mogoCalculate = ((mogoPIDval>=0)? 1 : -1)*min(abs(mogoMax),abs(mogoPIDval));
			liftCalculate = pidCalculate(liftPID, (customHeight)? liftHeight :liftPos[liftState], SensorValue[liftPot]);
		}
		else {
			mogoCalculate = vexRT(Btn5U)*127 - vexRT(Btn6U)*127;
			liftCalculate = vexRT(Ch3);
		}
		motor[liftTop] = liftCalculate + mogoCalculate;
		motor[liftBottomLeft] = motor[liftBottomRight] = liftCalculate - mogoCalculate;
		wait1Msec(20);
	}
}
void intakeMogo() {
	liftOverride = false;
	customHeight = true;
	liftHeight = SensorValue[liftPot];
	SensorValue[rightEnc] = SensorValue[leftEnc] = 0;
	mogoState = inish;
	int startVal = SensorValue[mogoPot];
	float targetAngle = gyroAngle;
	string value;
	while(SensorValue[mogoPot]>(inish+20)) {
		int distance = min(300,abs(startVal - SensorValue[mogoPot])*0.3);
		int val = pidCalculate(drivePID, distance, driveEnc);
		int leftVal = val + pidCalculate(gyroDrivePID, targetAngle, gyroAngle);
		int rightVal = val - pidCalculate(gyroDrivePID, targetAngle, gyroAngle);
		motor[LD1] = motor[LD2] = ((leftVal) >= 0 ? 1 : -1)*TrueSpeed[min(fabs(leftVal),127)];
		motor[RD1] = motor[RD2] = ((rightVal) >= 0 ? 1 : -1)*TrueSpeed[min(fabs(rightVal),127)];
		wait1Msec(20);
		sprintf(value, "%f", distance);
		displayLCDCenteredString(0, value);
		sprintf(value, "%f",	SensorValue[mogoPot]);
		displayLCDCenteredString(1, value);
	}
	customHeight = false;
	if(!bIfiAutonomousMode) {
		liftOverride = true;
	}
	motor[LD1] = motor[LD2] = motor[RD1] = motor[RD2] = 0;
	mogoState = in;
}
void lowerStack() {
	displayLCDCenteredString(1, "called");
	liftOverride = false;
	liftHeight = SensorValue[liftPot];
	int origHeight = liftHeight;
	mogoMax = 127;
	stopTask(clawTask);
	stopTask(fBarTask);
	motor[claw] = -40;
	int time = nPgmTime;
	mogoState = lower;
	customHeight = true;
	string value;
	int repsAtTarget = 0;
	while (repsAtTarget<2&&!vexRT[Btn8R]) {
		motor[fBar] =  fBarPower = -pidCalculate(fBarPID, abs(nPgmTime - time) * 4 + up, SensorValue[fBarPot]);
		//else {
		//	liftHeight = (1000-abs(nPgmTime - time)) *0.2 + origHeight;
		//}
		if (abs(SensorValue[mogoPot] - lower)<100) {
			repsAtTarget ++;
		}
		else
			repsAtTarget =0;
		sprintf(value, "%f", SensorValue[mogoPot]);
		displayLCDCenteredString(0, value);
		wait1Msec(20);
	}
	startTask(fBarTask);
	motor[claw] =127;
	//	liftHeight = 100+origHeight;
	fBarState = up;
	wait1Msec(500);
	if(!bIfiAutonomousMode) {
		liftOverride = true;
	}
	customHeight = false;
	startTask(clawTask);
}






/*
Driving PID and turning libraries courtesy of Brian Boxell, DCL 9605A

TrueSpeed mapping courtesy of Jordan Kiesel, BNS/24c

PID and Gyro libraries courtesy of Jason McKinney, QCC2/2625

All of this is designed to work with the Vex EDR system. Motors are given values between -127 and 127. The Truespeed mapping accounts
for the nonlinearity of the motor values so that you get smoother and more accurate accelerations. The gyro library by Jason McKinney is
specifically designed to account for drift in the Vex yaw rate gyroscope. Depending on the quality of your gyro, you may be able to omit
the functions in the monitorGyro task, and just use the raw data of the gyro.

In the implementation of this code, there are a bunch of variables and things defined elsewhere. These include global variables (notably the
gyroAngle float), and the initializations of the PIDs. You must initialize all PIDs at the beginning of your program.4
*/


/*
* uses PID to drive to the desired target, within the specified accuracy
* @param target: integer target value to drive to
* @param accuracy: integer value asssigned to the desired accuracy (drives to target +- this number)
*/
void driveTo(int target) {
	int targetAngle = gyroAngle;
	int rate;
  slewRate.lastTime = nPgmTime/1000.0;
	slewCut = false;
	wait1Msec(20);
	while (abs(driveEnc)<abs(target)) {
		if (target-driveEnc>0) {
			rate = 127;
		}
		else {
			rate = -127;
		}
		if (!slewCut) {
			rate = rateCalculate(slewRate, rate);
		}
		if (driveEnc>target/2.0) {
			slewCut = true;
		}
		motor[LD1] = motor[LD2] = rate + pidCalculate(gyroDrivePID, targetAngle, gyroAngle);
		motor[RD1] = motor[RD2] = rate - pidCalculate(gyroDrivePID, targetAngle, gyroAngle);
		wait1Msec(20);
	}
}

void driveTarget(int target, int accuracy, int time) {
	int startTime = nPgmTime;
	bool atTarget = false;
	int targetAngle = gyroAngle;
	int repsAtTarget = 0;
	string value;
	//go into the loop that will repeat to update motor values and break when at target
	while (!atTarget && (nPgmTime-startTime) < time) {
		//calculate the value the motors should be set at based on its position relative to the target
		int val = pidCalculate(drivePID, target, driveEnc);
		//the left and right drive values should be different in order to correct getting turned as specified by the gyro value
		int leftVal = val + pidCalculate(gyroDrivePID, targetAngle, gyroAngle);
		int rightVal = val - pidCalculate(gyroDrivePID, targetAngle, gyroAngle);
		motor[LD1] = motor[LD2] = ((leftVal) >= 0 ? 1 : -1)*TrueSpeed[min(fabs(leftVal),127)];
		motor[RD1] = motor[RD2] = ((rightVal) >= 0 ? 1 : -1)*TrueSpeed[min(fabs(rightVal),127)];
		//if the sensor value is within the desired range of the target
		if (abs(driveEnc-target) < accuracy) {
			//if the sensor value is within the range for multiple iterations of the loop where each loop is approximately 20ms
			if (repsAtTarget > 15) {
				//break out of the while loop
				atTarget = true;
			}
			else {
				repsAtTarget++;
			}
		}
		else {
			repsAtTarget = 0;
		}
		sprintf(value, "%f", driveEnc);
		displayLCDCenteredString(1, value);
		wait1Msec(20);
	}
	//zero the value of the encoder so that the next time this procedure is called, the encoder will be starting at zero again
	SensorValue[rightEnc] = SensorValue[leftEnc] = driveEnc-target;
	motor[LD1] = motor[LD2] = motor[RD1] = motor[RD2] = 0;
}


//updates the angle of the robot, makes it so that the angle is always described to be within -180 <= angle <= 180 degrees.
//this task runs in the background, the code could also just be copy and pasted into the main loop of the program and work the same.
task monitorGyro() {
	while (true) {
		//takes the summation of the gyro turning rates over time
		float deltaTime = (nPgmTime - time)/1000.0;
		time = nPgmTime;
		gyroAngle += gyro_get_rate(gyro)*deltaTime;
		//makes sure that the gyro angle is always represented between -180 and 180
		if (fabs(gyroAngle)>180) {
			gyroAngle = ((gyroAngle>0)? -1: 1)*(360-fabs(gyroAngle));
		}
		wait1Msec(20);
	}
}


/*
* uses PID to turn to the desired target, within the specified accuracy
* @param target: integer target value to drive to
* @param accuracy: integer value asssigned to the desired accuracy (drives to target +- this number)
*/
void gyroTurn(int target, int accuracy, int time) {
	int startTime = nPgmTime;
	bool gyroAtTarget = false;
	int repsAtTarget = 0;
	string value;
	//go into the loop that will repeat to update motor values and break when at target
	while (!gyroAtTarget  && (nPgmTime-startTime) < time) {
		// calculate the desired motor value based on the sensor value relative to the target
		float drive = pidCalculate(gyroPID, target, gyroAngle);
		drive = ((fabs(gyroAngle-target)>180)? -1 : 1)*drive;
		driveL(drive);
		driveR(drive);
		//if the sensor value is within the desired range of the target
		if (fabs(gyroAngle-target) < accuracy) {
			//if the sensor value is within the range for multiple iterations of the loop where each loop is approximately 20ms
			if (repsAtTarget > 15) {
				//break out of the loop
				gyroAtTarget = true;
			}
			else {
				repsAtTarget++;
			}
		}
		else {
			repsAtTarget = 0;
		}
		sprintf(value, "%f", gyroAngle);
		displayLCDCenteredString(0,value);
		sprintf(value, "%f", drive);
		displayLCDCenteredString(1,value);
		wait1Msec(20);
	}
	SensorValue[rightEnc] = SensorValue[leftEnc] = 0; //zero the value of the drive encoder
	motor[LD1] = motor[LD2] = motor[RD1] = motor[RD2] = 0;
}

//called from the gyro turn task, makes sure it is a valid motor input and updates drive motors;
void driveL(int val){
	val = (abs(val) > 127)? 127 * val/abs(val) : val; //ensure val is under 127
	motor[LD1] = motor[LD2] = ((val) >= 0 ? 1 : -1)*TrueSpeed[min(fabs(val),127)];
}
// same thing as driveL, but with a different negative sign
void driveR(int val){
	val = abs(val) > 127 ? 127 * val/abs(val) : val; //ensure val is under 127
	motor[RD1] = motor[RD2] = ((val) >= 0 ? -1 : 1)*TrueSpeed[min(fabs(val),127)];
}

//returns the minimum of 2 parameters, used in the TrueSpeed call
int min(int a, int b){
	if(a>b)
		return b;
	return a;
}





















//Essentially the "OS" for the LCD screen
task LCDScreen() {
	int index = 0;
	int sensorIndex = 0;
	string mainBattery, backupBattery;
	string mainMenu[] = {"Battery Voltage", "Check Sensors", "Auton Select", "Turn Check", "Drive Check"};
	string sensorArr[] = {"Left Encoder", "Right Encoder", "Gyro Angle", "Lift Pot", "Mogo Pot", "Four Bar Pot", "Four Bar Power"};
	string autonSelectArr[] = {"Auton Side", "Auton Routine"};
	string autonArr[] = {"2 cones in 20", "3 cones in 20", "3 cones in 10", "3 cones in 5", "5 cones", "Programming Skills"};
	int autonSelectIndex = 0;
	autonIndex = 0;
	string value;

	while (true) {
		displayLCDCenteredString(0, mainMenu[index]);
		displayLCDString(1,0, "<    Select    >");
		if (nLCDButtons == 1) {
			index = (index == 0)? 4: index-1;
			wait1Msec(250);
		}
		if (nLCDButtons == 4) {
			index = (index ==4)? 0: index+1;
			wait1Msec(250);
		}
		if (nLCDButtons ==2) {
			wait1Msec(150);
			if (index == 0) {
				while (nLCDButtons != 2) {
					clearLCDLine(0);
					clearLCDLine(1);
					displayLCDString(0, 0, "Primary: ");
					sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
					displayNextLCDString(mainBattery);
					displayLCDString(1, 0, "Secondary: ");
					sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0,'V'); //Build the value to be displayed
					displayNextLCDString(backupBattery);
					wait1Msec(20);
				}
				wait1Msec(250);
			}
			if (index ==3) {
				auton = 3;
				stopTask(liftMogoControl);
				//startTask(monitorGyro);
				wait1Msec(1000);
				gyroTurn(90, 2,99999999999);
				while(nLCDButtons!=2) {
					sprintf(value, "%f", gyroAngle);
					displayLCDCenteredString(1, value);
				}
			}
			if (index ==4) {

				auton = 4;
				stopTask(liftMogoControl);
				//startTask(monitorGyro);
				wait1Msec(1000);
				driveTarget(2000, 20,9999999999);
				while(nLCDButtons!=2) {
					sprintf(value, "%f", driveEnc);
					//displayLCDCenteredString(1, value);
					displayLCDCenteredString(1, "broken out");
				}
				/*intakeMogo();

				while(nLCDButtons!=2) {
				sprintf(value, "%f", SensorValue[mogoPot]);
				displayLCDCenteredString(0, value);
				//	displayLCDCenteredString(1, "lowered");
				wait1Msec(20);
				}*/
			}
			if (index == 1) {
				wait1Msec(150);
				while (nLCDButtons !=2) {
					displayLCDCenteredString(0,sensorArr[sensorIndex]);
					if (nLCDButtons == 1) {
						sensorIndex = (sensorIndex == 0)? 6: sensorIndex-1;
						wait1Msec(250);
					}
					if (nLCDButtons == 4) {
						sensorIndex = (sensorIndex ==6)? 0: sensorIndex+1;
						wait1Msec(250);
					}
					if (sensorIndex == 0) {
						sprintf(value, "%i", -SensorValue[leftEnc]);
					}
					else if (sensorIndex == 1) {
						sprintf(value, "%i", SensorValue[rightEnc]);
					}
					else if (sensorIndex == 2) {
						sprintf(value, "%f", gyroAngle);
					}
					else if (sensorIndex == 3) {
						sprintf(value, "%i", SensorValue[liftPot]);
					}
					else if (sensorIndex == 4) {
						sprintf(value, "%i", SensorValue[mogoPot]);
					}
					else if (sensorIndex == 5) {
						sprintf(value, "%i", SensorValue[fBarPot]);
					}
					else if (sensorIndex == 6) {
						sprintf(value, "%i", fBarPower);
					}
					displayLCDCenteredString(1,value);
					wait1Msec(20);
				}
				wait1Msec(250);
			}
			if (index == 2) {
				wait1Msec(150);
				while (true) {
					displayLCDCenteredString(0,autonSelectArr[autonSelectIndex]);
					if (nLCDButtons == 1) {
						autonSelectIndex = (autonSelectIndex == 0)? 1: autonSelectIndex-1;
						wait1Msec(250);
					}
					if (nLCDButtons == 4) {
						autonSelectIndex = (autonSelectIndex ==1)? 0: autonSelectIndex+1;
						wait1Msec(250);
					}
					if (nLCDButtons == 2) {
						int reps = 0;
						while (nLCDButtons == 2) {
							reps++;
							wait1Msec(20);
						}
						if (reps>40) {
							if (autonSelectIndex == 0) {
								while (nLCDButtons !=2) {
									if (nLCDButtons == 1 || nLCDButtons == 4) {
										left = (left == 1)? -1: 1;
										wait1Msec(250);
									}
									displayLCDCenteredString(1, (left==1)? "Left": "Right");
									wait1Msec(100);
									clearLCDLine(1);
									wait1Msec(100);
								}
							}
							else if (autonSelectIndex == 1) {
								while (nLCDButtons !=2) {
									if (nLCDButtons == 1) {
										autonIndex = (autonIndex == 0)? 5: autonIndex-1;
										wait1Msec(250);
									}
									if (nLCDButtons == 4) {
										autonIndex = (autonIndex == 5)? 0: autonIndex+1;
										wait1Msec(250);
									}

									displayLCDCenteredString(1, autonArr[autonIndex]);
									wait1Msec(100);
									clearLCDLine(1);
									wait1Msec(100);
								}
							}
						}
						else {
							break;
						}
					}
					if (autonSelectIndex == 0) {
						displayLCDCenteredString(1, (left==1)? "Left": "Right");
					}
					else if (autonSelectIndex == 1) {
						displayLCDCenteredString(1, autonArr[autonIndex]);
					}
					wait1Msec(20);
				}
				wait1Msec(250);
			}
		}
		wait1Msec(20);
	}
}
