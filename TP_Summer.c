#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, dgtl1,  safety,         sensorDigitalIn)
#pragma config(Sensor, dgtl6,  flywheelEnc,    sensorQuadEncoder)
#pragma config(Motor,  port2,           RD1,           tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           LD2,           tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           lLift,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rLift,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           flywheel,      tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           RD2,           tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LD1,           tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          intake,        tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

#include "./Truespeed.h"
#include "./VRCNERD-nerd_robotc-cfdb3c0a39c3/libPID/NERD_PID.c"

int min(int a, int b);
int max(int a, int b);
float calcRate();

task flywheelTask();
task datalogTask();

PID flywheelPID;

enum speeds {
	highFlag = 2100,
	lowFlag = 1850
};

enum speeds target = highFlag;

bool flywheelOn = true;
bool lastDown = true;

float ticksPerSecond;

float data[] = {0,0,0,0,0};

void pre_auton()
{
  bStopTasksBetweenModes = true;

}


task autonomous()
{

  AutonomousCodePlaceholderForTesting();
}


task usercontrol()
{
	int rightPower;
	int leftPower;

	startTask(datalogTask);
	startTask(flywheelTask);

  while (true)
  {
		rightPower = ((vexRT[Ch2] - vexRT[Ch1]) >= 0 ? 1 : -1)*TrueSpeed[min(fabs(vexRT[Ch2] - vexRT[Ch1]),127)];
		leftPower = ((vexRT[Ch2] + vexRT[Ch1]) >= 0 ? 1 : -1)*TrueSpeed[min(fabs(vexRT[Ch2] + vexRT[Ch1]),127)];

		motor[RD1] = motor[RD2] = rightPower;
		motor[LD1] = motor[LD2] = leftPower;

		lastDown = vexRT[Ch3] < -10;
		motor[lLift] = motor[rLift] = (fabs(vexRT[Ch3]) > 10)? vexRT[Ch3]: (lastDown)? -20: 0;

		motor[intake] = 127*vexRT[Btn5U] - 127*vexRT[Btn5D];

		if (vexRT[Btn8U]) {
			flywheelOn = !flywheelOn;
			wait1Msec(200);
		}

		if (vexRT[Btn7U]) {
			target = highFlag;
			wait1Msec(200);
		}
		else if(vexRT[Btn7L]) {
			target = lowFlag;
			wait1Msec(300);
		}
		string state = "Safety: ";
		sprintf(state, "%i", SensorValue[safety]);
		displayLCDCenteredString(0, state);
  }
}

task flywheelTask() {
	int power;

	long lastPosition = SensorValue[flywheelEnc];
	long lastTime = -1;
	float maxSpeed = 2500.0;
	pidInit(flywheelPID, 0.3, 0.03, 0.015, 999999,999999, 999999, 9999999);
	motor[flywheel] = 127;
	float kF;

	while (true) {
		kF = target/maxSpeed;
		float dT = (nPgmTime - lastTime)/1000.0;
		lastTime = nPgmTime;

		ticksPerSecond = (SensorValue[flywheelEnc] - lastPosition)/dT;
		lastPosition = SensorValue[flywheelEnc];

		for (int i = 0; i<4; i++) {
			data[i] = data[i+1];
		}
		data[4] = ticksPerSecond;

		delay(15);

		power = pidCalculate(flywheelPID, target, calcRate()) + 127*kF;
		power = TrueSpeed[max(min(power, 127),0)];
		motor[flywheel] = (flywheelOn)? power: 0;
		//motor[flywheel] = 127;
		lastTime = nPgmTime;
		lastPosition = SensorValue[flywheelEnc];
		wait1Msec(15);
	}
}

task datalogTask() {
	while(true) {
		datalogDataGroupStart ();
		datalogAddValue(0, calcRate());
		datalogAddValue(1, target);
		datalogDataGroupEnd();

		delay (100);
	}
}

float calcRate() {
	float sum = 0;
	for (int i = 0; i<5; i++) {
		sum+=data[i];
	}
	return sum/5.0;
}

int min(int a, int b){
	if(a>b)
		return b;
	return a;
}

int max(int a, int b) {
	if (a<b)
		return b;
	return a;
}
